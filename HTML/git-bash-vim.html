<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>git-bash-vim</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p><a href="http://www.fprintf.net/vimCheatSheet.html" title="Permalink to Vim Commands Cheat Sheet">Source</a></p>
<h1 id="vim-commands-cheat-sheet">Vim Commands Cheat Sheet</h1>
<hr />
<h2 id="how-to-exit">How to Exit</h2>
<p>:q[uit] Quit Vim. This fails when changes have been made.</p>
<p>:q[uit]! Quit without writing.</p>
<p>:cq[uit] Quit always, without writing.</p>
<p>:wq Write the current file and exit.</p>
<p>:wq! Write the current file and exit always.</p>
<p>:wq {file} Write to {file}. Exit if not editing the last</p>
<p>:wq! {file} Write to {file} and exit always.</p>
<p>:[range]wq[!] [file] Same as above, but only write the lines in [range].</p>
<p>ZZ Write current file, if modified, and exit.</p>
<p>ZQ Quit current file and exit (same as “:q!”).</p>
<hr />
<h2 id="editing-a-file">Editing a File</h2>
<p>:e[dit] Edit the current file. This is useful to re-edit the current file, when it has been changed outside of Vim.</p>
<p>:e[dit]! Edit the current file always. Discard any changes to the current buffer. This is useful if you want to start all over again.</p>
<p>:e[dit] {file} Edit {file}.</p>
<p>:e[dit]! {file} Edit {file} always. Discard any changes to the current buffer.</p>
<p>gf Edit the file whose name is under or after the cursor. Mnemonic: “goto file”.</p>
<hr />
<h2 id="inserting-text">Inserting Text</h2>
<p>a Append text after the cursor [count] times.</p>
<p>A Append text at the end of the line [count] times.</p>
<p>i Insert text before the cursor [count] times.</p>
<p>I Insert text before the first non-blank in the line [count] times.</p>
<p>gI Insert text in column 1 [count] times.</p>
<p>o Begin a new line below the cursor and insert text, repeat [count] times.</p>
<p>O Begin a new line above the cursor and insert text, repeat [count] times.</p>
<hr />
<h2 id="inserting-a-file">Inserting a file</h2>
<p>:r[ead] [name] Insert the file [name] below the cursor.</p>
<p>:r[ead] !{cmd} Execute {cmd} and insert its standard output below the cursor.</p>
<hr />
<h2 id="deleting-text">Deleting Text</h2>
<p>or x Delete [count] characters under and after the cursor</p>
<p>X Delete [count] characters before the cursor</p>
<p>d{motion} Delete text that {motion} moves over</p>
<p>dd Delete [count] lines</p>
<p>D Delete the characters under the cursor until the end of the line</p>
<p>{Visual}x or {Visual}d Delete the highlighted text (for {Visual} see [Selecting Text][1]).</p>
<p>{Visual}CTRL-H or {Visual} When in Select mode: Delete the highlighted text</p>
<p>{Visual}X or {Visual}D Delete the highlighted lines</p>
<p>:[range]d[elete] Delete [range] lines (default: current line)</p>
<p>:[range]d[elete] {count} Delete {count} lines, starting with [range]</p>
<hr />
<h2 id="changing-or-replacing-text">Changing (or Replacing) Text</h2>
<p>r{char} replace the character under the cursor with {char}.</p>
<p>R Enter Insert mode, replacing characters rather than inserting</p>
<p>~ Switch case of the character under the cursor and move the cursor to the right. If a [count] is given, do that many characters.</p>
<p>~{motion} switch case of {motion} text.</p>
<p>{Visual}~ Switch case of highlighted text</p>
<hr />
<h2 id="substituting">Substituting</h2>
<p>:[range]s[ubstitute]/{pattern}/{string}/[c][e][g][p][r][i][I] [count] For each line in [range] replace a match of {pattern} with {string}.</p>
<p>:[range]s[ubstitute] [c][e][g][r][i][I] [count] :[range]&amp;[c][e][g][r][i][I] [count] Repeat last :substitute with same search pattern and substitute string, but without the same flags. You may add extra flags</p>
<pre><code>The arguments that you can use for the substitute commands:
[c]  Confirm each substitution.  Vim positions the cursor on the matching
  string.  You can type:
      &#39;y&#39;      to substitute this match
      &#39;n&#39;      to skip this match
         to skip this match
      &#39;a&#39;      to substitute this and all remaining matches {not in Vi}
      &#39;q&#39;      to quit substituting {not in Vi}
      CTRL-E  to scroll the screen up {not in Vi}
      CTRL-Y  to scroll the screen down {not in Vi}.
[e]     When the search pattern fails, do not issue an error message and, in
  particular, continue in maps as if no error occurred.
[g]  Replace all occurrences in the line.  Without this argument,
  replacement occurs only for the first occurrence in each line.
[i]  Ignore case for the pattern.
[I]  Don&#39;t ignore case for the pattern.
[p]  Print the line containing the last substitute.</code></pre>
<hr />
<h2 id="copying-and-moving-text">Copying and Moving Text</h2>
<p>“{a-zA-Z0-9.%#:-”} Use register {a-zA-Z0-9.%#:-"} for next delete, yank or put (use uppercase character to append with delete and yank) ({.%#:} only work with put).</p>
<p>:reg[isters] Display the contents of all numbered and named registers.</p>
<p>:reg[isters] {arg} Display the contents of the numbered and named registers that are mentioned in {arg}.</p>
<p>:di[splay] [arg] Same as :registers.</p>
<p>["x]y{motion} Yank {motion} text [into register x].</p>
<p>["x]yy Yank [count] lines [into register x]</p>
<p>["x]Y yank [count] lines [into register x] (synonym for yy).</p>
<p>{Visual}["x]y Yank the highlighted text [into register x] (for {Visual} see [Selecting Text][1]).</p>
<p>{Visual}["x]Y Yank the highlighted lines [into register x]</p>
<p>:[range]y[ank] [x] Yank [range] lines [into register x].</p>
<p>:[range]y[ank] [x] {count} Yank {count} lines, starting with last line number in [range] (default: current line), [into register x].</p>
<p>["x]p Put the text [from register x] after the cursor [count] times.</p>
<p>["x]P Put the text [from register x] before the cursor [count] times.</p>
<p>["x]gp Just like “p”, but leave the cursor just after the new text.</p>
<p>["x]gP Just like “P”, but leave the cursor just after the new text.</p>
<p>:[line]pu[t] [x] Put the text [from register x] after [line] (default current line).</p>
<p>:[line]pu[t]! [x] Put the text [from register x] before [line] (default current line).</p>
<hr />
<h2 id="undoredorepeat">Undo/Redo/Repeat</h2>
<p>u Undo [count] changes.</p>
<p>:u[ndo] Undo one change.</p>
<p>CTRL-R Redo [count] changes which were undone.</p>
<p>:red[o] Redo one change which was undone.</p>
<p>U Undo all latest changes on one line. {Vi: while not moved off of it}</p>
<p>. Repeat last change, with count replaced with [count].</p>
<hr />
<h2 id="moving-around">Moving Around</h2>
<pre><code>Basic motion commands:

        k
      h   l
        j</code></pre>
<p>h or</p>
<p>[count] characters to the left (exclusive).</p>
<p>l or or</p>
<p>[count] characters to the right (exclusive).</p>
<p>k or or CTRL-P [count] lines upward</p>
<p>j or or CTRL-J or or CTRL-N [count] lines downward (linewise).</p>
<p>0 To the first character of the line (exclusive).</p>
<p>To the first character of the line (exclusive).</p>
<p>^ To the first non-blank character of the line</p>
<p>$ or</p>
<p>To the end of the line and [count - 1] lines downward</p>
<p>g0 or g When lines wrap (‘wrap on): To the first character of the screen line (exclusive). Differs from “0” when a line is wider than the screen. When lines don’t wrap (’wrap’ off): To the leftmost character of the current line that is on the screen. Differs from “0” when the first character of the line is not on the screen.</p>
<p>g^ When lines wrap (‘wrap’ on): To the first non-blank character of the screen line (exclusive). Differs from “^” when a line is wider than the screen. When lines don’t wrap (‘wrap’ off): To the leftmost non-blank character of the current line that is on the screen. Differs from “^” when the first non-blank character of the line is not on the screen.</p>
<p>g$ or g shift right</p>
<p>v start Visual mode per character.</p>
<p>V start Visual mode linewise.</p>
<p>exit Visual mode without making any changes</p>
<hr />
<h2 id="how-to-suspend">How to Suspend</h2>
<p>CTRL-Z Suspend Vim, like “:stop”. Works in Normal and in Visual mode. In Insert and Command-line mode, the CTRL-Z is inserted as a normal character.</p>
<p>:sus[pend][!] or :st[op][!] Suspend Vim. If the ‘!’ is not given and ‘autowrite’ is set, every buffer with changes and a file name is written out. If the ‘!’ is given or ‘autowrite’ is not set, changed buffers are not written, don’t forget to bring Vim back to the foreground later!</p>
<hr />
</body>
</html>
